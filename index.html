<!doctype html>
<html lang="bn">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Alpha â€“ Cinematic Starfield</title>
  <style>
    html, body { height:100%; margin:0; overflow:hidden; background:#000; font-family:monospace; }
    /* layered sky gradient */
    body::before{
      content:"";
      position:fixed; inset:0;
      background:
        radial-gradient(1200px 800px at 50% 25%, rgba(130,160,255,.12), transparent 60%),
        radial-gradient(900px 650px at 20% 10%, rgba(255,220,180,.08), transparent 60%),
        radial-gradient(1000px 700px at 80% 15%, rgba(180,255,240,.08), transparent 60%),
        linear-gradient(#03040a, #070914 55%, #05060d);
      z-index:-3;
    }
    /* vignette */
    body::after{
      content:"";
      position:fixed; inset:0;
      background: radial-gradient(100% 120% at 50% 40%, transparent 65%, rgba(0,0,0,.45) 100%);
      z-index:-1; pointer-events:none;
    }

    canvas{ position:fixed; inset:0; z-index:-2; }
    .wrap{ height:100%; display:grid; place-items:center; padding:6vmin; }
    img{ max-width:86vw; border-radius:20px; box-shadow:0 10px 60px rgba(255,255,255,.35); }
    h1{
      position:fixed; top:18px; left:50%; transform:translateX(-50%);
      letter-spacing:.35em; color:#fff;
      text-shadow:0 0 8px rgba(255,255,255,.6), 0 0 24px rgba(0,255,255,.25);
      animation:glow 2.4s ease-in-out infinite alternate;
    }
    @keyframes glow{
      from{ filter: drop-shadow(0 0 2px #fff) drop-shadow(0 0 12px #0ff); }
      to{   filter: drop-shadow(0 0 6px #fff) drop-shadow(0 0 24px #7cf); }
    }
  </style>
</head>
<body>
  <canvas id="sky"></canvas>
  <h1>Alpha</h1>

  <main class="wrap">
    <img src="Picsart_25-10-19_21-27-42-155.jpg" alt="Surreal Art">
  </main>

  <script>
    // ===== Cinematic starfield =====
    const c = document.getElementById('sky');
    const x = c.getContext('2d');
    let W,H,DPR;

    const pointer = {x:.5,y:.5};
    addEventListener('mousemove',e=>{pointer.x=e.clientX/innerWidth; pointer.y=e.clientY/innerHeight;},{passive:true});
    addEventListener('touchmove',e=>{const t=e.touches[0]; if(t){pointer.x=t.clientX/innerWidth; pointer.y=t.clientY/innerHeight;}},{passive:true});

    function resize(){
      DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
      W = c.width  = Math.floor(innerWidth*DPR);
      H = c.height = Math.floor(innerHeight*DPR);
      c.style.width = innerWidth+'px';
      c.style.height= innerHeight+'px';
    }
    addEventListener('resize', resize); resize();

    // layers: background drift stars + orbiters around center
    const BG_COUNT = 260, ORBIT_COUNT = 160;
    const stars = [];
    const center = {x:()=>W*0.5, y:()=>H*0.42};

    // helper
    const rand = (a,b)=>a+Math.random()*(b-a);
    function hsv(h,s,v){ // returns css rgba from hsv (0..360, 0..1, 0..1)
      const f=(n,k=(n+h/60)%6)=>v - v*s*Math.max(Math.min(k,4-k,1),0);
      const r=f(5), g=f(3), b=f(1);
      return `rgba(${(r*255)|0},${(g*255)|0},${(b*255)|0},`;
    }

    // background wanderers
    for(let i=0;i<BG_COUNT;i++){
      const d = Math.random();
      stars.push({
        type:'bg',
        x: Math.random()*W, y: Math.random()*H,
        r: (0.4+Math.random()*1.6)*(0.5+d),
        vx: rand(-0.06,0.06)*(0.3+d),
        vy: rand(-0.06,0.06)*(0.3+d),
        a: Math.random(), ad: (Math.random()>.5?1:-1)*rand(0.004,0.012),
        hue: rand(190,230), depth:d
      });
    }

    // orbiters (slow swirl around center)
    for(let i=0;i<ORBIT_COUNT;i++){
      const R = rand(Math.min(W,H)*0.12, Math.min(W,H)*0.55);
      stars.push({
        type:'orb',
        r: rand(0.7,1.9),
        rad: R,                // orbit radius
        ang: rand(0, Math.PI*2),
        vel: rand(0.0006, 0.0018)*(Math.random()<0.5?-1:1), // angular velocity
        tw: rand(0.004,0.012), // twinkle speed
        a: rand(0.4,1),
        hueBase: rand(190,260) // blue-cyan-violet range
      });
    }

    let hueShift = 0; // slow scene hue shift
    function frame(){
      x.clearRect(0,0,W,H);

      // subtle base vignette/gradient layer
      const g = x.createRadialGradient(center.x(), center.y(), 0, center.x(), center.y(), Math.max(W,H)*0.7);
      g.addColorStop(0, `rgba(255,255,255,0.02)`);
      g.addColorStop(1, `rgba(0,0,0,0.35)`);
      x.fillStyle = g;
      x.fillRect(0,0,W,H);

      // parallax offset from pointer
      const px = (pointer.x-0.5)*0.03*W;
      const py = (pointer.y-0.5)*0.03*H;

      // animate all stars
      for(const s of stars){
        if(s.type==='bg'){
          s.x += s.vx; s.y += s.vy;
          if(s.x<-10) s.x=W+10; if(s.x>W+10) s.x=-10;
          if(s.y<-10) s.y=H+10; if(s.y>H+10) s.y=-10;
          s.a += s.ad; if(s.a<0.15||s.a>1) s.ad*=-1;

          x.beginPath();
          x.globalCompositeOperation='screen';
          x.globalAlpha = s.a;
          x.fillStyle = hsv((s.hue+hueShift)%360, 0.45, 1) + '1)';
          x.arc(s.x - px*s.depth, s.y - py*s.depth, s.r*DPR, 0, Math.PI*2);
          x.fill();
        } else {
          // orbiters
          s.ang += s.vel;
          // twinkle
          s.a += s.tw * (Math.random()>.5?1:-1);
          if(s.a<0.15) s.a=0.15; if(s.a>1) s.a=1;

          const ox = center.x() + Math.cos(s.ang)*s.rad + px*0.6;
          const oy = center.y() + Math.sin(s.ang)*s.rad + py*0.6;

          x.beginPath();
          x.globalCompositeOperation='screen';
          x.globalAlpha = s.a;
          x.fillStyle = hsv((s.hueBase + hueShift)%360, 0.6, 1) + '1)';
          x.arc(ox, oy, s.r*DPR, 0, Math.PI*2);
          x.fill();

          // soft halo
          x.globalAlpha = s.a*0.25;
          x.beginPath();
          x.fillStyle = hsv((s.hueBase + hueShift)%360, 0.6, 1) + '0.25)';
          x.arc(ox, oy, s.r*3*DPR, 0, Math.PI*2);
          x.fill();
        }
      }
      x.globalAlpha = 1;
      hueShift = (hueShift + 0.05) % 360; // very slow color drift
      requestAnimationFrame(frame);
    }
    frame();
  </script>
</body>
</html>
